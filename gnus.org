* Introduction

This configuration file contains my Gnus configuration, for accessing mail at
Gmail.  Since my Gmail account is set up to get mail from the rest of my email
accounts, and send as them too, I only need to have this one account set up.

* Implementation
** Package Installation

You do need gnus.  However, I'm pretty sure that it comes preinstalled on Emacs.
Also, BBDB, which is not installed by default.

#+begin_src emacs-lisp :tangle yes
(stemacs-require '(bbdb))
#+end_src

** Configuration

This is from the [[http://www.emacswiki.org/emacs/GnusGmail][Emacs Wiki]]
article on Gnus.  These are the IMAP and SMTP settings necessary.

#+name: init
#+begin_src emacs-lisp
(setq gnus-select-method
      '(nnimap "gmail"
	       (nnimap-address "imap.gmail.com")
	       (nnimap-server-port 993)
	       (nnimap-stream ssl)))

(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
      smtpmail-auth-credentials '(("smtp.gmail.com" 587
				   "brenns10@gmail.com" nil))
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
#+end_src

Also required is a .authinfo file with SMTP and IMAP server entries.  It
prevents you from having to specify the password.  This file should definitely
have 600 permissions.  The file should look something like this:

#+BEGIN_EXAMPLE
machine imap.gmail.com login [email] password [password] port 993
machine smtp.gmail.com login [email] password [password] port 587
#+END_EXAMPLE

The following settings set my From address accordingly (although I may want to
mail from different addresses).

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Stephen Brennan"
      user-mail-address "brenns10@gmail.com")
#+end_src

This code is cut and pasted from [[https://eschulte.github.io/emacs24-starter-kit/starter-kit-gnus.html][Starter Kit Gnus]].  It makes the summary view
look much more like an email list.

#+begin_src emacs-lisp :tangle yes
; http://groups.google.com/group/gnu.emacs.gnus/browse_thread/thread/a673a74356e7141f
(when window-system
  (setq gnus-sum-thread-tree-indent "  ")
  (setq gnus-sum-thread-tree-root "") ;; "● ")
  (setq gnus-sum-thread-tree-false-root "") ;; "◯ ")
  (setq gnus-sum-thread-tree-single-indent "") ;; "◎ ")
  (setq gnus-sum-thread-tree-vertical        "│")
  (setq gnus-sum-thread-tree-leaf-with-other "├─► ")
  (setq gnus-sum-thread-tree-single-leaf     "╰─► "))
(setq gnus-summary-line-format
      (concat
       "%0{%U%R%z%}"
       "%3{│%}" "%1{%d%}" "%3{│%}" ;; date
       "  "
       "%4{%-20,20f%}"               ;; name
       "  "
       "%3{│%}"
       " "
       "%1{%B%}"
       "%s\n"))
(setq gnus-summary-display-arrow t)
#+end_src

This sets Gnus to display all email messages when I select a group, not just the
read ones.

#+begin_src emacs-lisp :tangle yes
(setq gnus-parameters
  '((".*"
     (display . all)
     (gnus-use-scoring nil))))
#+end_src

This has Gnus display the newest emails first.

#+begin_src emacs-lisp :tangle yes
(setq gnus-thread-sort-functions
  '(gnus-thread-sort-by-most-recent-number))
#+end_src

This tells Gnus to ask me whether to verify signatures.

#+begin_src emacs-lisp :tangle yes
(setq mm-verify-option 'always)
(setq mm-decrypt-option 'always)
(setq mm-encrypt-option 'guided)
(setq gnus-buttonized-mime-types '("multipart/signed"))
#+end_src

Here I tell Gnus to always use the Topic mode instead of the Group mode.

#+begin_src emacs-lisp :tangle yes
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
#+end_src

This will automatically quit gnus non-interactively when Emacs exits, so I don't
need to worry about correctly exiting it myself.

#+begin_src emacs-lisp :tangle yes
(setq gnus-interactive-exit nil)
(add-hook 'kill-emacs-hook 'gnus-group-exit)
#+end_src

Don't let Gnus take the entire window **every time I open something**.

#+begin_src emacs-lisp :tangle yes
(setq gnus-use-full-window nil)
#+end_src

Keys that make navigating Gnus a hell of a lot easier:

#+begin_src emacs-lisp :tangle yes
(defun stemacs-switch-close ()
  "Switch window and close it."
  (interactive)
  (progn
    (other-window 1)
    (delete-window)))

(defun stemacs-mouse-close (event)
  "Switch to the clicked window and close it."
  (interactive "e")
  (let ((w (posn-window (event-start event))))
    (if (window-valid-p w)
      (delete-window (select-window w))
      nil)))

(add-hook 'gnus-summary-mode-hook
  (lambda ()
    (progn
      (define-key gnus-summary-mode-map (kbd "v x") 'stemacs-switch-close)
      (define-key gnus-summary-mode-map (kbd "n") 'next-line)
      (define-key gnus-summary-mode-map (kbd "p") 'previous-line))))
(add-hook 'gnus-article-mode-hook
  (lambda ()
    (define-key gnus-article-mode-map [down-mouse-2] 'stemacs-mouse-close)))
#+end_src

For contacts, I'm using BBDB.  This seems to work for me.  I downloaded my
Google Contacts in VCF, and used bbdb-vcard to import them.

#+begin_src emacs-lisp :tangle yes
;;; bbdb
(require 'bbdb)
(bbdb-initialize 'gnus 'message)
(setq
 bbdb-file "~/.bbdb"
 bbdb-offer-save 'auto
 bbdb-notice-auto-save-file t
 bbdb-expand-mail-aliases t
 bbdb-canonicalize-redundant-nets-p t
 bbdb-always-add-addresses t
 bbdb-complete-name-allow-cycling t
 )
#+end_src

This is a fix for PGP encryption.  From Arch forums (not by me).

#+begin_src emacs-lisp :tangle yes
(defun epg--list-keys-1 (context name mode)
  (let ((args (append (if (epg-context-home-directory context)
			  (list "--homedir"
				(epg-context-home-directory context)))
		      '("--with-colons" "--no-greeting" "--batch"
			"--with-fingerprint" "--with-fingerprint")
		      (unless (eq (epg-context-protocol context) 'CMS)
			'("--fixed-list-mode"))))
	(list-keys-option (if (memq mode '(t secret))
			      "--list-secret-keys"
			    (if (memq mode '(nil public))
				"--list-keys"
			      "--list-sigs")))
	(coding-system-for-read 'binary)
	keys string field index)
    (if name
	(progn
	  (unless (listp name)
	    (setq name (list name)))
	  (while name
	    (setq args (append args (list list-keys-option (car name)))
		  name (cdr name))))
      (setq args (append args (list list-keys-option))))
    (with-temp-buffer
      (apply #'call-process
	     (epg-context-program context)
	     nil (list t nil) nil args)
      (goto-char (point-min))
      (while (re-search-forward "^[a-z][a-z][a-z]:.*" nil t)
	(setq keys (cons (make-vector 15 nil) keys)
	      string (match-string 0)
	      index 0
	      field 0)
	(while (and (< field (length (car keys)))
		    (eq index
			(string-match "\\([^:]+\\)?:" string index)))
	  (setq index (match-end 0))
	  (aset (car keys) field (match-string 1 string))
	  (setq field (1+ field))))
      (nreverse keys))))
#+end_src
